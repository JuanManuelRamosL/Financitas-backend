import { EventEmitter } from 'events';

type Quantizations = 'int4' | 'int8' | 'fp6' | 'fp8' | 'fp16' | 'bf16' | 'unknown';
type ResponseFormatTypes = "string" | "number" | "boolean";
type ResponseFormatObject = {
    type: "object";
    properties: Record<string, {
        type: ResponseFormatTypes | ResponseFormatTypes[];
        description?: string;
        enum?: any[];
    }>;
    required?: string[];
    additionalProperties?: boolean;
};
type ResponseFormatArray = {
    type: "array";
    items: ResponseFormatObject | ResponseFormatArray;
};
type Config = {
    httpReferer?: string;
    xTitle?: string;
    reasoning?: {
        exclude?: boolean;
        enabled?: boolean;
    } & ({
        effort?: "high" | "medium" | "low";
    } | {
        max_tokens?: number;
    });
    response_format?: {
        type: 'json_object';
    } | {
        type: 'json_schema';
        json_schema: {
            name: string;
            strict: boolean;
            schema: ResponseFormatObject;
        };
    };
    provider?: {
        order?: string[];
        ignore?: string[];
        quantizations?: Quantizations[];
        data_collection?: 'allow' | 'deny';
        allow_fallbacks?: boolean;
        require_parameters?: boolean;
    };
    stop?: string | string[];
    min_p?: number;
    max_tokens?: number;
    temperature?: number;
    top_a?: number;
    top_p?: number;
    top_k?: number;
    frequency_penalty?: number;
    presence_penalty?: number;
    repetition_penalty?: number;
    seed?: number;
    logit_bias?: {
        [key: number]: number;
    };
    tools?: Tool[];
    tool_choice?: ToolChoice;
    transforms?: ['middle-out'] | [];
    prediction?: {
        type: 'content';
        content: string;
    };
} & ({
    models: string[];
    route: 'fallback';
} | {
    model?: string;
    route?: undefined;
});
type FunctionDescription = {
    description?: string;
    name: string;
    parameters: object;
};
type Tool = {
    type: 'function';
    function: FunctionDescription;
};
type ToolChoice = 'none' | 'auto' | {
    type: 'function';
    function: {
        name: string;
    };
};
type VerboseContent = {} | {
    type: 'text';
    content: string;
} | {
    type: 'image_url';
    image_url: {
        url: string;
    };
};
interface Message {
    role: 'system' | 'user' | 'assistant';
    content: string | VerboseContent[];
}
type Error = {
    code: number;
    message: string;
};
type FunctionCall = {
    name: string;
    arguments: string;
};
type ToolCall = {
    id: string;
    type: 'function';
    function: FunctionCall;
};
interface ResponseChoiceNonStreaming {
    finish_reason: string | null;
    message: {
        content: string | null;
        role: string;
        reasoning: string | null;
        tool_calls?: ToolCall[];
    };
    error?: Error;
}
interface ResponseUsage {
    /** Including images and tools if any */
    prompt_tokens: number;
    /** The tokens generated */
    completion_tokens: number;
    /** Sum of the above two fields */
    total_tokens: number;
}
interface ResponseSuccess {
    id: string;
    choices: ResponseChoiceNonStreaming[];
    created: number;
    model: string;
    system_fingerprint?: string;
    usage?: ResponseUsage;
}
interface ResponseError {
    error: {
        status: number;
        message: string;
        metadata?: unknown;
    };
}
interface GenerationStats {
    data: {
        id: string;
        model: string;
        streamed: false;
        generation_time: number;
        created_at: Date;
        tokens_prompt: number;
        tokens_completion: number;
        native_tokens_prompt: number;
        native_tokens_completion: number;
        num_media_prompt: null;
        num_media_completion: null;
        origin: string;
        total_cost: number;
        cache_discount: null;
    };
}

type types_Config = Config;
type types_Error = Error;
type types_FunctionCall = FunctionCall;
type types_FunctionDescription = FunctionDescription;
type types_GenerationStats = GenerationStats;
type types_Message = Message;
type types_Quantizations = Quantizations;
type types_ResponseChoiceNonStreaming = ResponseChoiceNonStreaming;
type types_ResponseError = ResponseError;
type types_ResponseFormatArray = ResponseFormatArray;
type types_ResponseFormatObject = ResponseFormatObject;
type types_ResponseFormatTypes = ResponseFormatTypes;
type types_ResponseSuccess = ResponseSuccess;
type types_ResponseUsage = ResponseUsage;
type types_Tool = Tool;
type types_ToolCall = ToolCall;
type types_ToolChoice = ToolChoice;
type types_VerboseContent = VerboseContent;
declare namespace types {
  export type { types_Config as Config, types_Error as Error, types_FunctionCall as FunctionCall, types_FunctionDescription as FunctionDescription, types_GenerationStats as GenerationStats, types_Message as Message, types_Quantizations as Quantizations, types_ResponseChoiceNonStreaming as ResponseChoiceNonStreaming, types_ResponseError as ResponseError, types_ResponseFormatArray as ResponseFormatArray, types_ResponseFormatObject as ResponseFormatObject, types_ResponseFormatTypes as ResponseFormatTypes, types_ResponseSuccess as ResponseSuccess, types_ResponseUsage as ResponseUsage, types_Tool as Tool, types_ToolCall as ToolCall, types_ToolChoice as ToolChoice, types_VerboseContent as VerboseContent };
}

declare const errorCodesAndMesssages: {
    400: string;
    401: string;
    402: string;
    408: string;
    429: string;
    502: string;
    503: string;
};
declare class OpenRouter {
    apiKey: string;
    globalConfig: Config;
    constructor(apiKey: string, globalConfig?: Config);
    chat(messages: Message[], config?: Config, signal?: AbortSignal): Promise<{
        success: true;
        data: ResponseSuccess;
    } | {
        success: false;
        errorCode: number;
        errorMessage: string;
        metadata?: unknown;
    } | {
        success: false;
        error: "AbortSignal" | unknown;
    }>;
    getGenerationStats(id: string): Promise<GenerationStats>;
}
declare class OpenRouterStream extends EventEmitter {
    apiKey: string;
    globalConfig: Config;
    constructor(apiKey: string, globalConfig?: Config);
    /** Sends back chunks. First message sent back might be "hello" and the second chunk might be " world" */
    chatStreamChunk(messages: Message[], config?: Config): Promise<void>;
    chatStreamWhole(messages: Message[], config?: Config): Promise<void>;
}

export { OpenRouter, OpenRouterStream, errorCodesAndMesssages, types };
